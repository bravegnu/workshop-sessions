= Linux Userspace GPIO Access
Zilogic Systems

== GPIO

[role="two-column"]
=== Introduction

[role="left"]

 * *General Purpose Input Output(GPIO)* are single pin IO, represents
   voltage signal as binary logic level `high` and `low`.

 * Typically GPIO `high` maps to voltage closer to VCC and `low` maps
   to voltage closer to ground.

 * `high` state is considered as logical `1` and low as `0`.

[role="right"]
image::figures/gpio-bistate.png[]

=== GPIO Direction

 * It can operate in both the directions, as an `input` to sample the
   logic level or as an `output` to drive any logic level

 * Their direction as input or output can be chosen.

 * The pin status can be read or modified from software.

=== GPIO Ports and Pins

 * The GPIO controllers are also called GPIO ports.

 * A GPIO ports, controls a set of GPIO pins

[role="two-column"]
=== GPIO Controller

[role="left"]

* GPIO controller is the hardware which provides register interface
  using which the pin status can be accessed.

[role="right"]
image::figures/gpio-ctrl.png[]

[role="two-column"]
=== GPIO Controller Contd.

[role="left"]

* GPIO controller resides in the memory bus of the SOC.

[role="right"]
image::figures/gpio-arm.png[]

=== GPIO Numbering

 * The processor pin has to be configured as GPIO in the pinmux
   configuration.

 * GPIOs pins are referred as, particular pin in a particular port
 
 * Example: P2_3 - pin 3 in port 2

=== Linux GPIO Numbering

 * Vybrid VF510 has 6 GPIO ports, Port 0 - Port 5

 * Each port controls 32 pins

 * Pins are numbered sequentially

   - Port 0, Pin Numbers: 0 - 31
   - Port 1, Pin Numbers: 32 - 63
   - Port 2, Pin Numbers: 64 - 95
   - ...

=== GPIO Usage in ZKit-ARM-VF51

[options="header"]
|====================================
| Device | Port Pin | Pin Sequence No
| RLED   | P2_6     | GPIO70
| BLED   | P2_0     | GPIO64
| GLED   | P2_1     | GPIO65
| KEY1   | P2_5     | GPIO69
| KEY2   | P2_3     | GPIO67
|====================================

== SYSFS GPIO

[role="two-column"]
=== GPIO Files in Sysfs

[role="left"]
* Inside `sysfs` in path '/sys/class/gpio` we have files which allows
  to monitor and control the GPIO.

* For each GPIO a folder '/sys/class/gpio/gpio<no>' is created and it
  would have below files.

* the `direction` file allows to control direction of pin and `value`
  file would allow to access the pin state.

[role="right"]
----
/sys/class/gpio/
| -- gpio<no>
     | -- value
     ` -- direction 
----

== LEDs

[role="two-column"]
=== LED Circuitry

[role="left"]

* The LED glows when anode is connected to Vcc and it's cathode is
  grounded.

* A electronic switch is connected between LED and ground, which when
  closed the LED glows.

* The outpin of CPU can be connected to the switch to open or close
  it.

[role="right"]
image::figures/led-simple.png[]

[role="two-column"]
=== LED Circuitry

[role="left"]
* A current limiting resistor can be used to reduce the current
  flowing through LED, to reduce burn out of LED.

* MOSFET or Transistor can act as a electronic switch.

[role="right"]
image::figures/leds.png[]

=== GPIO Request

* GPIOs can be used internally by other kernel subsystems

* GPIO has to be made available to user, by the kernel, before they
  can be used

* If GPIO is used by kernel, this will fail

----
$ echo 65 > /sys/class/gpio/export
----

* You would find `/sys/class/gpio/gpio65` available, if no other
  peripheral subsystem has not reserved it.

* A GPIO pin can be freed as shown below

----
$ echo 65 > /sys/class/gpio/unexport
----
 
=== GPIO Direction

* The processor pin can be configured as output pin by writing 'out'
to the GPIO direction file

----
$ echo out > /sys/class/gpio/gpio65/direction
----

* The processor pin can be configured as output pin by writing 'in' to
the GPIO direction file

----
$ echo in > /sys/class/gpio/gpio65/direction
----

=== GPIO State 

 * When value '1' or '0' written in the value file, it can drive logic
   level high or low.

----
$ echo 1 > /sys/class/gpio/gpio65/value
----

 * The value file can be read to know the state of input pin.

----
$ cat /sys/class/gpio/gpio65/value
----

=== LED Glow Program

[source,python]
----
include::code/led.py[]
----

=== GPIO Module

[source,python]
----
include::code/gpio.py[]
----

=== LED Blinky Program

The GPIO related actions are implemented as a GPIO class and it is
used in blink code 
link:{include:code/gpio.py.datauri}["gpio.py",filename="gpio.py"]

[source,python]
----
include::code/led-blink.py[]
----

=== Try Out

* Glow the tri color LED connected to GPIO64, 65 & 70 through command
  line.
 
* Modify the LED Blink Code
  link:{include:code/led-blink.py.datauri}["led-blink.py",filename="led-blink.py"]
  to change the color of led every one second.

=== Try Out Codes

* Code for LED Color change is
  link:{include:code/led-chcolor.py.datauri}["led-chcolor.py",filename="led-chcolor.py"]

== Keys

[role="two-column"]
=== GPIO Input States
[role="left"]
* GPIOs in input mode can be of three states `high`, `low` or `floating`.

* GPIOs if they are not connected to any signal it would be a floating
  input and said to be open.

* The `floating pins` doesn't have a fixed state and it would pick
  near by signal and would have unstable state.

[role="right"]
image::figures/gpio-states.png[]


[role="two-column"]
=== Handling GPIOs in Input Mode
[role="left"]
* The inputs lines has to be fixed to a default state by tying that
  - to *VCC* for default high state or 
  - to *GND* for default low state.

* Making a pin to stay high, by connecting it to VCC through a
  resistor is called `pull-up`.

* Making a pin to stay low, by connecting it to GND through a resistor
  is called `pull-down`.

[role="right"]
image::figures/gpio-pullupdown.png[]

=== Keys Circuitry

* A key/switch has *two* terminals, when pressed it mechanically
  connects the terminals.

* One terminal of switch can be connected to GND other to the input
  pin.

* When the is key pressed the switch is closed and the input pin is
  grounded.

* if unpressed the switch is open and which would have undefined
  state.

[role="two-column"]
=== Keys Circuitry Contd.

[role="left"]
* The GPIO pin can be defaulted to high level by a pull-up, so input
  would be high when pin is open.

* When the key is unpressed the GPIO stays high and when pressed it
  gets low.

* To detect whether a key is pressed / released or idle, pin has to be
  sensed in program.

[role="right"]
image::figures/keys.png[]

=== Code

[source,python]
----
include::code/key-debounce.py[]
----

=== Tryout

* Modify the code
  link:{include:code/key-debounce.py.datauri}["key-debounce.py",filename="key-debounce.py"]
  to show key status
  - print "Key 1 Pressed" in LCD, when Key 1 pressed
  - glow GREEN LED, when Key 2 pressed 

=== Tryout Codes

* The code for the tryout is 
  link:{include:code/key-status.py.datauri}["key-status.py",filename="key-status.py"]

== References

=== Links

* http://slideplayer.com/slide/11129925/

* https://developer.android.com/things/hardware/hardware-101.html

== Backup Slides

[role="two-column"]
=== Seven Seg

[role="left"]
image::figures/segment.png[width=300]

[role="right"]
image::figures/sseg-pinmap.png[]

=== Program for Seven Segment

[source,python]
----
include::code/sseg.py[]
----

== GPIO Usage Models

=== Various GPIO Usage patterns

* Individual GPIOs for single LED, Keys, Relays, Reed switches and
  solenoid valves.

* Parallel GPIOs for 7 Segment, Stepper Motor etc.,

* Multiplexed GPIOs for Multi Seven Segment Array, Matrix Keypad etc.,

* GPIOs can be coupled with timer for periodic signalling or to create
  pulse trains of various width.

=== Bitbanging

* GPIOs as its name suggests, has countless possibility that using
  which we can build simple busses like 
  - I2C, 
  - 1 wire, 
  - SPI and 
  - even complex Memory bus

* This done using Bitbanging is a technique, which allows to simulate
  serial busses using software over GPIO.

=== Key Debounce

* The switches or keys used are mechanical devices and when key is
  pressed or depressed they tend to vibrate creating noises until it
  settles down.

* This condition can be handled in hardware by adding a debounce
  filter.

* It can also be handled in software by waiting for specific time from
  the event occurence till it settles down.

* This delay time is typically around few hundred millisecond and
  called debounce delay.

=== Programming for Keys

[source,python]
----
include::code/key.py[]
----

=== Key Polling

* Since the key press is asynchronous, it has to be polled
  continuously or periodically.

* Continuously polling for key may burn the CPU, instead periodical
  polling should be sufficient for keys.

* Typical key stroke period by humans, couldn't be less than few
  hundred millisecs.

* it's enough that we can poll for key press once in 100 msec. 

=== Sensors and Actuators

 * Sensors - produces two values 'on' or 'off'
   - Door Sensor
   - Presence Sensor
   - Smoke Detector

 * Actuators
   - Relays: Turn ON / OFF Appliances
   - Solenoids

